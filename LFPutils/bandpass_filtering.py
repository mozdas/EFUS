"""
This file contains the script for bandpass filtering a down sampled evoked LFP data.

    Required Files:
        This script uses down sampled (1000 Hz) evoked LFP data for analysis. It can be generated by checking the option when generating dictionay for the LFP Analysis and then running the LFP Pipeline.

    Input:
        main_path: Path for the data.
        low_cutff, high_cut_off : Cut off frequencies of the bandpass filter.
        order_of_filter : The order of the filter.
    
    Output:
        Creates figures under 'analyzed' folder

    Created on  July , 2018
    Author: Abdulkadir Gokce - Please contact him or Mehmet Ozdas in case of any questions.

"""

import os
import shutil
import pickle
import numpy as np
import math
import matplotlib.pyplot as plt
from utils.filtering import bandpassFilter


"""
#########Parameters for testing
main_path = '/media/yaniklab/05d01d78-2bd6-4a4e-b573-df49ccacb71c/2018_04_13_FUSs1_EphysM1_E-FUS_NBBB68/'
#main_path = '/media/yaniklab/05d01d78-2bd6-4a4e-b573-df49ccacb71c/test_1234567/'
low_cutoff = 20
high_cutoff = 40
order_of_filter = 4
probe = 0
group = 0
tw = 1
y_scale = 70
########
"""


def bandpass_filtering(bandpassParams):

    main_path = bandpassParams['main_path']
    low_cutoff = bandpassParams['low_cutoff']
    high_cutoff = bandpassParams['high_cutoff']
    order_of_filter = bandpassParams['order_of_filter']
    probe = 0
    group = bandpassParams['group']
    tw = bandpassParams['tw']
    y_scale = bandpassParams['y_scale']

    directories_to_skip = ['analyzed','analysis_files', 'other', 'log.txt', 'notes.docs', '.DS_Store', '._.DS_Store']
    dirs = os.listdir(main_path)

    for folder in (folder for folder in dirs if (folder not in directories_to_skip)):
        
        parameters_path = '{0}{1}/paramsDict.p'.format(main_path, folder)
        p = pickle.load(open(parameters_path,'rb')) #Load LFP analysis parameters


        evoked_data_path = '{0}{1}/probe_{2}_group_{3}/probe_{4}_group_{5}_evoked_down_sampled.pickle'.format(main_path, folder, probe, group, probe, group)
        fid = open(evoked_data_path,'rb')
        evoked_data = pickle.load(fid) #Load down sampled evoked LFP data
        fid.close()
        evoked = evoked_data['evoked']
        stim_timestamps = evoked_data['stim_timestamps']
        len_time_window = tw * 60 * 1000 #Length of each window

        #Preallocate analysis arrays
        filtered_evoked = np.zeros((p['nr_of_electrodes_per_group'], int((p['evoked_pre']+p['evoked_post'])*1000) ))
        errors = np.zeros(( p['nr_of_electrodes_per_group'], int((p['evoked_pre']+p['evoked_post'])*1000) ))
        num_window = int(np.max(stim_timestamps) / len_time_window)
        windows = np.arange(0, num_window*tw, tw)
        evoked_window_avgs = np.zeros((num_window, len(evoked[0]), len(evoked[0][0])))
        evoked_window_err = np.zeros((num_window, len(evoked[0]), len(evoked[0][0])))
        evoked_window_amps = np.zeros(( p['nr_of_electrodes_per_group'], num_window))
        evoked_window_peak_errs = np.zeros((p['nr_of_electrodes_per_group'], num_window))
        lfp_averages = np.zeros((p['nr_of_electrodes_per_group'],num_window))
        evoked_window_correction = np.zeros((num_window, len(evoked[0])))
        evoked_window_amps_corrected = np.zeros((p['nr_of_electrodes_per_group'], num_window))

        bandpass_filter = bandpassFilter(rate=1000, high=high_cutoff, low=low_cutoff, order=order_of_filter, axis=2)
        filtered_evoked = bandpass_filter(evoked) #Bandpass filterind the data



        for window in range(num_window):
            #Finding all the evoked data for which the time stamp falls in the window of interest
            evoked_window = filtered_evoked[np.all([stim_timestamps > window * len_time_window, stim_timestamps < (window + 1) * len_time_window], axis = 0)]
            evoked_window_avgs[window] = np.mean(evoked_window, axis=0) #  mean of evoked window
            evoked_window_std = np.std(evoked_window, axis=0) #Standard deviation of the data in the time window
            evoked_window_err[window] = evoked_window_std / math.sqrt(len(evoked_window)) # standart error of evoked window

            for trode in range(p['nr_of_electrodes_per_group']):
                evoked_window_amps[trode][window] = np.min(evoked_window_avgs[window][trode]) 
                evoked_window_correction = np.mean(evoked_window_avgs[:, :, 0:int(p['evoked_pre']*p['sample_rate'])], axis=2) #Average values between 'evoked_pre' and 0 for correction
                #The mean of the -(pre evoked):0 interval is substracted from the minimum amplitude of each respective time window to obtain amplitude difference
                evoked_window_amps_corrected[trode][window] = np.min(evoked_window_avgs[window][trode]) - evoked_window_correction[window][trode] #Correction for the difference between peak and initial state
                min_error = evoked_window_err[window][trode][np.where(evoked_window_avgs[window][trode] == np.min(evoked_window_avgs[window][trode]))]
                if len(min_error) == 1:
                    evoked_window_peak_errs[trode][window] = min_error

        time = np.linspace(-p['evoked_pre']*1000, p['evoked_post']*1000, int((p['evoked_pre']+p['evoked_post'])*1000))



        #Cleaning and/or creating directories
        analyzed_path = '{0}analyzed'.format(main_path)
        analyzed_folder_path = '{0}/{1}'.format(analyzed_path, folder)
        analyzed_group_path = '{0}/probe_{1}_group_{2}'.format(analyzed_folder_path, probe, group)
        save_path = '{0}/bandpass_filtered'.format(analyzed_group_path)
        pdf_path = '{0}/pdf'.format(save_path)
        svg_path = '{0}/svg'.format(save_path)

        if os.path.exists(save_path):
            shutil.rmtree(save_path)

        if not os.path.exists(save_path):
            os.mkdir(save_path)

        if not os.path.exists(pdf_path):
            os.mkdir(pdf_path)

        if not os.path.exists(svg_path):
            os.mkdir(svg_path)

        for trode in range(p['nr_of_electrodes_per_group']):
             
            if not os.path.exists('{0}/electrode-{1}'.format(pdf_path, trode)):
                os.mkdir('{0}/electrode-{1}'.format(pdf_path, trode))

            if not os.path.exists('{0}/electrode-{1}'.format(svg_path, trode)):
                os.mkdir('{0}/electrode-{1}'.format(svg_path, trode))

        
        for window in range(num_window):
            for trode in range(p['nr_of_electrodes_per_group']):

                fig = plt.figure()
                plt.plot(time, evoked_window_avgs[window][trode], 'k-')
                plt.fill_between(time, evoked_window_avgs[window][trode]-evoked_window_err[window][trode], evoked_window_avgs[window][trode]+evoked_window_err[window][trode])

                plt.title('Bandpass Filtered ({0}-{1} Hertz) Evoked LFP Electrode-{2} Window-{3}'.format(low_cutoff, high_cutoff, trode, window))
                plt.ylabel('Peak voltage (uV)')
                plt.xlabel('Time (ms)')
                plt.ylim(np.floor(np.min(filtered_evoked) / 100) * y_scale, np.ceil(np.max(filtered_evoked) / 100) * y_scale)
                plt.xlim(-p['evoked_pre']*1000, p['evoked_post']*1000)
                
                print('Window-{0} / Electrode-{1}'.format(window, trode))
                plt.savefig('{0}/electrode-{1}/window-{2}.pdf'.format(pdf_path, trode, window), format = 'pdf')
                plt.savefig('{0}/electrode-{1}/window-{2}.svg'.format(svg_path, trode, window), format = 'svg')
                plt.close()
        

        for trode in range(p['nr_of_electrodes_per_group']): 
            fig = plt.figure()
            plt.plot(windows, evoked_window_amps_corrected[trode])
            plt.errorbar(windows, evoked_window_amps_corrected[trode], yerr = evoked_window_peak_errs[trode], color='olive')

            plt.title('Bandpass Filtered ({0}-{1} Hertz) Evoked LFP Electrode-{2} Peak Amlitudes'.format(low_cutoff, high_cutoff, trode, window))
            plt.xlabel('Time (min)')
            plt.ylabel('Peak voltage (uV)')

            ylim_min = np.floor(np.min(filtered_evoked) / 100) * y_scale
            ylim_max = np.ceil(np.max(filtered_evoked) / 100) * y_scale
            plt.ylim(ylim_min, ylim_max)
            plt.xlim(0, (num_window-1)*tw)

            y_ticks = np.arange((ylim_min-ylim_min%100), (ylim_max-ylim_max%100), 100)
            x_ticks = np.arange(0, (num_window-1)*tw, tw)
            plt.axes().set_yticks(y_ticks, minor=True)
            plt.axes().set_xticks(x_ticks, minor=True)
            plt.axes().grid(which='both')

            print('Peak Amplitudes Electrode-{0}\n'.format(trode))
            plt.savefig('{0}/electrode-{1}.pdf'.format(pdf_path, trode), format = 'pdf')
            plt.savefig('{0}/electrode-{1}.svg'.format(svg_path, trode), format = 'svg')
            plt.close()





